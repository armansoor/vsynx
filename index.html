<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Procedural Modular Synth</title>
    <style>
        :root {
            --bg-color: #2b2b2b;
            --module-bg: #444;
            --text-color: #eee;
            --accent: #00ffcc;
            --cable-color: #ff5555;
        }

        body {
            margin: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
            user-select: none;
        }

        /* Toolbar */
        #toolbar {
            padding: 10px;
            background: #1a1a1a;
            border-bottom: 2px solid #555;
            display: flex;
            gap: 10px;
            z-index: 100;
            position: relative;
        }

        button {
            background: #333;
            color: white;
            border: 1px solid #666;
            padding: 5px 15px;
            cursor: pointer;
            font-family: inherit;
        }

        button:hover { background: #555; }
        button:active { background: var(--accent); color: black; }

        /* Workspace */
        #rack {
            position: relative;
            width: 100vw;
            height: calc(100vh - 50px);
        }

        /* SVG Layer for Cables */
        svg#cable-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Let clicks pass through to modules */
            z-index: 1;
        }

        .cable-path {
            fill: none;
            stroke: var(--cable-color);
            stroke-width: 4px;
            stroke-linecap: round;
        }

        /* Modules */
        .module {
            position: absolute;
            background: var(--module-bg);
            border: 2px solid #666;
            border-radius: 4px;
            width: 150px;
            padding: 10px;
            box-shadow: 4px 4px 10px rgba(0,0,0,0.5);
            z-index: 2;
            cursor: grab;
        }

        .module-header {
            background: #222;
            padding: 5px;
            margin: -10px -10px 10px -10px;
            text-align: center;
            font-weight: bold;
            cursor: grab;
        }

        .control-group {
            margin-bottom: 10px;
        }

        label { display: block; font-size: 0.8em; margin-bottom: 2px; }

        input[type=range] {
            width: 100%;
            cursor: pointer;
        }

        /* Ports (Jacks) */
        .ports {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
        }

        .port {
            width: 20px;
            height: 20px;
            background: #222;
            border: 2px solid #888;
            border-radius: 50%;
            position: relative;
            cursor: crosshair;
        }

        .port:hover { border-color: var(--accent); }
        .port.input::before { content: 'IN'; position: absolute; top: -15px; left: 0; font-size: 0.6em; }
        .port.output::before { content: 'OUT'; position: absolute; top: -15px; left: -5px; font-size: 0.6em; }

    </style>
</head>
<body>

<div id="toolbar">
    <button onclick="addModule('VCO')">Add VCO (Oscillator)</button>
    <button onclick="addModule('VCA')">Add VCA (Gain)</button>
    <button onclick="resumeContext()">Start Audio Engine</button>
    <span style="margin-left:auto; align-self:center; font-size: 0.8em; color: #888;">Drag cables from OUT to IN</span>
</div>

<div id="rack">
    <svg id="cable-layer"></svg>
    </div>

<script>
    // --- 1. Audio Context & Engine ---
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const ctx = new AudioContext();
    
    // Resume context on user interaction (browser policy)
    function resumeContext() {
        if (ctx.state === 'suspended') {
            ctx.resume();
        }
    }

    // --- 2. State Management ---
    let modules = [];
    let cables = [];
    let dragCable = null; // Temp object for dragging
    let dragModule = null; // Temp object for moving modules

    // --- 3. Module Class Definitions ---
    class Module {
        constructor(type, x, y) {
            this.id = 'mod_' + Date.now();
            this.type = type;
            this.x = x;
            this.y = y;
            this.inputs = {};
            this.outputs = {};
            this.audioNode = null;
            
            this.element = this.createUI();
            this.initAudio();
            document.getElementById('rack').appendChild(this.element);
            
            modules.push(this);
        }

        initAudio() {
            if (this.type === 'VCO') {
                this.audioNode = ctx.createOscillator();
                this.audioNode.type = 'sawtooth';
                this.audioNode.frequency.value = 440;
                this.audioNode.start();
                this.outputs['out'] = this.audioNode;
            } else if (this.type === 'VCA') {
                this.audioNode = ctx.createGain();
                this.audioNode.gain.value = 0.5;
                this.inputs['in'] = this.audioNode;
                this.outputs['out'] = this.audioNode;
            } else if (this.type === 'OUTPUT') {
                this.audioNode = ctx.destination;
                this.inputs['in'] = this.audioNode;
            }
        }

        createUI() {
            const div = document.createElement('div');
            div.className = 'module';
            div.style.left = this.x + 'px';
            div.style.top = this.y + 'px';
            div.id = this.id;

            // Header for Dragging
            const header = document.createElement('div');
            header.className = 'module-header';
            header.innerText = this.type;
            header.onmousedown = (e) => startDragModule(e, this);
            div.appendChild(header);

            // Controls
            if (this.type === 'VCO') {
                this.addKnob(div, 'Freq', 50, 2000, 440, val => this.audioNode.frequency.value = val);
                this.addSelect(div, ['sine', 'square', 'sawtooth', 'triangle'], val => this.audioNode.type = val);
            } else if (this.type === 'VCA') {
                this.addKnob(div, 'Level', 0, 1, 0.5, val => this.audioNode.gain.value = val);
            }

            // Ports
            const portsDiv = document.createElement('div');
            portsDiv.className = 'ports';

            // Input Port
            if (this.type !== 'VCO') {
                const port = document.createElement('div');
                port.className = 'port input';
                port.dataset.type = 'in';
                port.dataset.moduleId = this.id;
                port.onmouseup = (e) => endCableDrag(e, this.id, 'in');
                portsDiv.appendChild(port);
            } else {
                portsDiv.appendChild(document.createElement('div')); // Spacer
            }

            // Output Port
            if (this.type !== 'OUTPUT') {
                const port = document.createElement('div');
                port.className = 'port output';
                port.dataset.type = 'out';
                port.dataset.moduleId = this.id;
                port.onmousedown = (e) => startCableDrag(e, this.id, 'out');
                portsDiv.appendChild(port);
            }

            div.appendChild(portsDiv);
            return div;
        }

        addKnob(parent, labelText, min, max, def, callback) {
            const group = document.createElement('div');
            group.className = 'control-group';
            const label = document.createElement('label');
            label.innerText = labelText;
            const input = document.createElement('input');
            input.type = 'range';
            input.min = min;
            input.max = max;
            input.step = 0.01;
            input.value = def;
            input.oninput = (e) => callback(parseFloat(e.target.value));
            
            group.appendChild(label);
            group.appendChild(input);
            parent.appendChild(group);
        }

        addSelect(parent, options, callback) {
            const group = document.createElement('div');
            group.className = 'control-group';
            const select = document.createElement('select');
            select.style.width = "100%";
            options.forEach(opt => {
                const o = document.createElement('option');
                o.value = opt;
                o.innerText = opt;
                if(opt === 'sawtooth') o.selected = true;
                select.appendChild(o);
            });
            select.onchange = (e) => callback(e.target.value);
            group.appendChild(select);
            parent.appendChild(group);
        }
    }

    // --- 4. Logic & Interaction ---

    // Initial Output Module
    new Module('OUTPUT', 600, 200);

    function addModule(type) {
        // Random offset for new modules
        const x = 50 + Math.random() * 200;
        const y = 50 + Math.random() * 200;
        new Module(type, x, y);
    }

    // --- Module Dragging Logic ---
    function startDragModule(e, module) {
        dragModule = {
            mod: module,
            offsetX: e.clientX - module.x,
            offsetY: e.clientY - module.y
        };
        window.addEventListener('mousemove', onDragModule);
        window.addEventListener('mouseup', stopDragModule);
    }

    function onDragModule(e) {
        if (!dragModule) return;
        dragModule.mod.x = e.clientX - dragModule.offsetX;
        dragModule.mod.y = e.clientY - dragModule.offsetY;
        dragModule.mod.element.style.left = dragModule.mod.x + 'px';
        dragModule.mod.element.style.top = dragModule.mod.y + 'px';
        updateCables();
    }

    function stopDragModule() {
        dragModule = null;
        window.removeEventListener('mousemove', onDragModule);
        window.removeEventListener('mouseup', stopDragModule);
    }

    // --- Cable Patching Logic ---
    function startCableDrag(e, modId, portType) {
        e.stopPropagation(); // Prevent module drag
        const portEl = e.target;
        const rect = portEl.getBoundingClientRect();
        
        dragCable = {
            fromMod: modId,
            startX: rect.left + rect.width / 2,
            startY: rect.top + rect.height / 2,
            currentX: e.clientX,
            currentY: e.clientY,
            tempLine: document.createElementNS('http://www.w3.org/2000/svg', 'path')
        };

        dragCable.tempLine.setAttribute('class', 'cable-path');
        dragCable.tempLine.style.opacity = '0.5';
        document.getElementById('cable-layer').appendChild(dragCable.tempLine);
        
        window.addEventListener('mousemove', onCableDrag);
        window.addEventListener('mouseup', abortCableDrag);
    }

    function onCableDrag(e) {
        if (!dragCable) return;
        dragCable.currentX = e.clientX;
        dragCable.currentY = e.clientY;
        drawCurve(dragCable.tempLine, dragCable.startX, dragCable.startY, dragCable.currentX, dragCable.currentY);
    }

    function endCableDrag(e, toModId, portType) {
        if (!dragCable) return;
        e.stopPropagation();

        // Connect Audio Logic
        const sourceMod = modules.find(m => m.id === dragCable.fromMod);
        const destMod = modules.find(m => m.id === toModId);

        // Validation: Don't connect to self, don't connect input to input
        if (sourceMod && destMod && sourceMod !== destMod) {
            // Audio Web API Connection
            sourceMod.outputs['out'].connect(destMod.inputs['in']);

            // Save Connection State
            cables.push({
                from: dragCable.fromMod,
                to: toModId,
                element: createCableElement(dragCable.fromMod, toModId)
            });
        }
        
        cleanupDrag();
    }

    function abortCableDrag() {
        cleanupDrag();
    }

    function cleanupDrag() {
        if (dragCable) {
            dragCable.tempLine.remove();
            dragCable = null;
            window.removeEventListener('mousemove', onCableDrag);
            window.removeEventListener('mouseup', abortCableDrag);
        }
    }

    // --- Drawing Utilities ---
    function createCableElement(fromId, toId) {
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('class', 'cable-path');
        document.getElementById('cable-layer').appendChild(path);
        updateSingleCable(path, fromId, toId);
        return path;
    }

    function updateCables() {
        cables.forEach(c => {
            updateSingleCable(c.element, c.from, c.to);
        });
    }

    function updateSingleCable(pathEl, fromId, toId) {
        // Find DOM elements for ports
        const fromMod = document.getElementById(fromId);
        const toMod = document.getElementById(toId);
        
        if (!fromMod || !toMod) return;

        const outPort = fromMod.querySelector('.port.output');
        const inPort = toMod.querySelector('.port.input');
        
        const r1 = outPort.getBoundingClientRect();
        const r2 = inPort.getBoundingClientRect();

        const x1 = r1.left + r1.width / 2;
        const y1 = r1.top + r1.height / 2;
        const x2 = r2.left + r2.width / 2;
        const y2 = r2.top + r2.height / 2;

        drawCurve(pathEl, x1, y1, x2, y2);
    }

    function drawCurve(pathEl, x1, y1, x2, y2) {
        // Bezier curve with "droop" logic based on distance
        const dist = Math.hypot(x2 - x1, y2 - y1);
        const droop = Math.min(dist * 0.5, 200); 
        
        // Control points
        const cp1x = x1;
        const cp1y = y1 + droop;
        const cp2x = x2;
        const cp2y = y2 + droop;

        const d = `M ${x1} ${y1} C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${x2} ${y2}`;
        pathEl.setAttribute('d', d);
    }

    // Main Loop
    function loop() {
        requestAnimationFrame(loop);
        // If we had a sequencer, it would update visual playheads here
    }
    loop();

</script>
</body>
</html>
